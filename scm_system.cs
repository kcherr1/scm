/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */


public class scm_system : global::System.IDisposable {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal scm_system(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(scm_system obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  ~scm_system() {
    Dispose();
  }

  public virtual void Dispose() {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          SCMPINVOKE.delete_scm_system(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
      global::System.GC.SuppressFinalize(this);
    }
  }

  public scm_system(int arg0, int arg1, int arg2, int arg3) : this(SCMPINVOKE.new_scm_system(arg0, arg1, arg2, arg3), true) {
  }

  public void render_sphere(double[] P, double[] M, int channel) {
    SCMPINVOKE.scm_system_render_sphere(swigCPtr, P, M, channel);
  }

  public void flush_cache() {
    SCMPINVOKE.scm_system_flush_cache(swigCPtr);
  }

  public void render_cache() {
    SCMPINVOKE.scm_system_render_cache(swigCPtr);
  }

  public void update_cache() {
    SCMPINVOKE.scm_system_update_cache(swigCPtr);
  }

  public void flush_queue() {
    SCMPINVOKE.scm_system_flush_queue(swigCPtr);
  }

  public void import_queue(string arg0) {
    SCMPINVOKE.scm_system_import_queue(swigCPtr, arg0);
    if (SCMPINVOKE.SWIGPendingException.Pending) throw SCMPINVOKE.SWIGPendingException.Retrieve();
  }

  public void export_queue(SWIGTYPE_p_std__string arg0) {
    SCMPINVOKE.scm_system_export_queue(swigCPtr, SWIGTYPE_p_std__string.getCPtr(arg0));
    if (SCMPINVOKE.SWIGPendingException.Pending) throw SCMPINVOKE.SWIGPendingException.Retrieve();
  }

  public void append_queue(scm_step arg0) {
    SCMPINVOKE.scm_system_append_queue(swigCPtr, scm_step.getCPtr(arg0));
  }

  public void render_queue() {
    SCMPINVOKE.scm_system_render_queue(swigCPtr);
  }

  public int add_scene(int arg0) {
    int ret = SCMPINVOKE.scm_system_add_scene(swigCPtr, arg0);
    return ret;
  }

  public void del_scene(int arg0) {
    SCMPINVOKE.scm_system_del_scene(swigCPtr, arg0);
  }

  public scm_scene get_scene(int arg0) {
    global::System.IntPtr cPtr = SCMPINVOKE.scm_system_get_scene(swigCPtr, arg0);
    scm_scene ret = (cPtr == global::System.IntPtr.Zero) ? null : new scm_scene(cPtr, false);
    return ret;
  }

  public int add_step(int arg0) {
    int ret = SCMPINVOKE.scm_system_add_step(swigCPtr, arg0);
    return ret;
  }

  public void del_step(int arg0) {
    SCMPINVOKE.scm_system_del_step(swigCPtr, arg0);
  }

  public scm_step get_step(int arg0) {
    global::System.IntPtr cPtr = SCMPINVOKE.scm_system_get_step(swigCPtr, arg0);
    scm_step ret = (cPtr == global::System.IntPtr.Zero) ? null : new scm_step(cPtr, false);
    return ret;
  }

  public int get_scene_count() {
    int ret = SCMPINVOKE.scm_system_get_scene_count(swigCPtr);
    return ret;
  }

  public double set_scene_blend(double arg0) {
    double ret = SCMPINVOKE.scm_system_set_scene_blend(swigCPtr, arg0);
    return ret;
  }

  public int get_step_count() {
    int ret = SCMPINVOKE.scm_system_get_step_count(swigCPtr);
    return ret;
  }

  public scm_step get_step_blend(double arg0) {
    scm_step ret = new scm_step(SCMPINVOKE.scm_system_get_step_blend(swigCPtr, arg0), true);
    return ret;
  }

  public bool get_synchronous() {
    bool ret = SCMPINVOKE.scm_system_get_synchronous(swigCPtr);
    return ret;
  }

  public void set_synchronous(bool b) {
    SCMPINVOKE.scm_system_set_synchronous(swigCPtr, b);
  }

  public float get_current_ground(double[] v) {
    float ret = SCMPINVOKE.scm_system_get_current_ground(swigCPtr, v);
    return ret;
  }

  public float get_minimum_ground() {
    float ret = SCMPINVOKE.scm_system_get_minimum_ground(swigCPtr);
    return ret;
  }

  public scm_sphere get_sphere() {
    global::System.IntPtr cPtr = SCMPINVOKE.scm_system_get_sphere(swigCPtr);
    scm_sphere ret = (cPtr == global::System.IntPtr.Zero) ? null : new scm_sphere(cPtr, false);
    return ret;
  }

  public scm_render get_render() {
    global::System.IntPtr cPtr = SCMPINVOKE.scm_system_get_render(swigCPtr);
    scm_render ret = (cPtr == global::System.IntPtr.Zero) ? null : new scm_render(cPtr, false);
    return ret;
  }

  public scm_scene get_fore() {
    global::System.IntPtr cPtr = SCMPINVOKE.scm_system_get_fore(swigCPtr);
    scm_scene ret = (cPtr == global::System.IntPtr.Zero) ? null : new scm_scene(cPtr, false);
    return ret;
  }

  public scm_scene get_back() {
    global::System.IntPtr cPtr = SCMPINVOKE.scm_system_get_back(swigCPtr);
    scm_scene ret = (cPtr == global::System.IntPtr.Zero) ? null : new scm_scene(cPtr, false);
    return ret;
  }

  public int acquire_scm(string arg0) {
    int ret = SCMPINVOKE.scm_system_acquire_scm(swigCPtr, arg0);
    if (SCMPINVOKE.SWIGPendingException.Pending) throw SCMPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public int release_scm(string arg0) {
    int ret = SCMPINVOKE.scm_system_release_scm(swigCPtr, arg0);
    if (SCMPINVOKE.SWIGPendingException.Pending) throw SCMPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public scm_scene find_scene(string arg0) {
    global::System.IntPtr cPtr = SCMPINVOKE.scm_system_find_scene(swigCPtr, arg0);
    scm_scene ret = (cPtr == global::System.IntPtr.Zero) ? null : new scm_scene(cPtr, false);
    if (SCMPINVOKE.SWIGPendingException.Pending) throw SCMPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public scm_cache get_cache(int arg0) {
    global::System.IntPtr cPtr = SCMPINVOKE.scm_system_get_cache(swigCPtr, arg0);
    scm_cache ret = (cPtr == global::System.IntPtr.Zero) ? null : new scm_cache(cPtr, false);
    return ret;
  }

  public scm_file get_file(int arg0) {
    global::System.IntPtr cPtr = SCMPINVOKE.scm_system_get_file(swigCPtr, arg0);
    scm_file ret = (cPtr == global::System.IntPtr.Zero) ? null : new scm_file(cPtr, false);
    return ret;
  }

  public float get_page_sample(int arg0, double[] v) {
    float ret = SCMPINVOKE.scm_system_get_page_sample(swigCPtr, arg0, v);
    return ret;
  }

  public SWIGTYPE_p_float get_page_sample4v(int arg0, double[] v) {
    global::System.IntPtr cPtr = SCMPINVOKE.scm_system_get_page_sample4v(swigCPtr, arg0, v);
    SWIGTYPE_p_float ret = (cPtr == global::System.IntPtr.Zero) ? null : new SWIGTYPE_p_float(cPtr, false);
    return ret;
  }

  public bool get_page_status(int arg0, long arg1) {
    bool ret = SCMPINVOKE.scm_system_get_page_status(swigCPtr, arg0, arg1);
    return ret;
  }

  public void get_page_bounds(int arg0, long arg1, SWIGTYPE_p_float arg2, SWIGTYPE_p_float arg3) {
    SCMPINVOKE.scm_system_get_page_bounds(swigCPtr, arg0, arg1, SWIGTYPE_p_float.getCPtr(arg2), SWIGTYPE_p_float.getCPtr(arg3));
    if (SCMPINVOKE.SWIGPendingException.Pending) throw SCMPINVOKE.SWIGPendingException.Retrieve();
  }

}
